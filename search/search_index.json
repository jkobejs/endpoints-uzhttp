{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"endpoints-uzhttp"},{"location":"/index.html#endpoints-uzhttp","text":"Endpoints server interpreter backed by uzhttp.\nYou Probably Shouldn’t Use It Because You Probably Shouldn’t Use uzhttp™.","title":"endpoints-uzhttp"},{"location":"/index.html#server","text":"\"io.github.jkobejs\" %% \"endpoints-uzhttp-server\" % \"0.0.0+6-b60be3bc+20200521-0107-SNAPSHOT\"\nAPI documentation","title":"Server"},{"location":"/index.html#endpoints","text":"The Endpoints interpreter provides intepret and interpretaPure methods that can be chained using orElse method and integrated to your uzhttp server.\nFor instance, given the following endpoint definition:\nval items =\n  endpoint(\n    get(\n      path / \"items\" / segment[String](\"category\") /? qs[Option[Int]](\"page\")\n    ),\n    ok(\n      jsonResponse[List[Item]],\n      Some(\"List all the items of the given category\")\n    )\n  )\n\nval itemId = segment[String](\"id\")\n\nval item =\n  endpoint(\n    get(path / \"item\" / itemId),\n    wheneverFound(\n      ok(jsonResponse[Item], Some(\"The item identified by 'id'\")),\n      Some(\"Item not found\")\n    )\n  )\nIt can be implemented as follows:\nval handler: PartialFunction[uzhttp.Request, ZIO[Any with Blocking, HTTPError, uzhttp.Response]] =\n  items.interpretPure {\n    case (category, page) =>\n      List(Item(s\"first item from category $category and page $page\"))\n  } orElse\n    item.interpret(id => UIO.some(Item(id.toString)))\nThe result is a partial function that can be integrated in your server like any other partial function that satisfies given type definition using uzhttp.server.Server’s handleSome method.","title":"Endpoints"},{"location":"/index.html#error-handling","text":"When the server processes requests, three kinds of errors can happen: the incoming request doesn’t match any endpoint, the request does match an endpoint but is invalid (e.g. one parameter has a wrong type), or an exception is thrown.","title":"Error handling"},{"location":"/index.html#the-incoming-request-doesn-t-match-any-endpoint","text":"In that case, since interpreters return partial function of type\nPartialFunction[UzRequest, ZIO[R with Blocking, HTTPError, UzResponse]]\nuzhttp server will return 404 error.","title":"The incoming request doesn’t match any endpoint"},{"location":"/index.html#the-incoming-request-is-invalid","text":"In that case, endpoints returns a “Bad Request” (400) response reporting all the errors in a JSON array. You can change this behavior by overriding the handleClientErrors method.","title":"The incoming request is invalid"},{"location":"/index.html#an-exception-is-thrown","text":"If an exception is thrown during request decoding, or when running the business logic, or when encoding the response, endpoints returns an “Internal Server Error” (500) response reporting the error in a JSON array. You can change this behavior by overriding the handleServerError method.","title":"An exception is thrown"},{"location":"/full-example.html","text":"","title":"full-example"},{"location":"/full-example.html#full-example","text":"Let’s start with defining our domain model.\n// Our domain model just contains a counter value\ncase class Counter(value: Int)\n\n// The operations that we can apply to our counter\nsealed trait Operation\nobject Operation {\n  case class Set(value: Int) extends Operation\n  case class Add(delta: Int) extends Operation\n}\nAfter we have our domain defined let’s describe HTTP API that we will use.\nimport endpoints.{ algebra, generic }\n\ntrait CounterEndpoints\n    extends algebra.EndpointsWithCustomErrors\n    with algebra.JsonEntitiesFromSchemas\n    with algebra.BasicAuthentication\n    with generic.JsonSchemas {\n\n  // HTTP endpoint for querying the current value of the counter. Uses the HTTP\n  // verb ''GET'' and the path ''/counter''. Returns the current value of the counter\n  // in a JSON object. (see below for the `counterJson` definition)\n  val currentValue =\n    authenticatedEndpoint(Get, (path / \"counter\"), counterJsonResponse)\n\n  // HTTP endpoint for updating the value of the counter. Uses the HTTP verb ''POST''\n  // and the path ''/counter''. The request entity contains an `Operation` object encoded\n  // in JSON. The endpoint returns the current value of the counter in a JSON object.\n  val update = authenticatedEndpoint(Post, path / \"counter\", counterJsonResponse, jsonRequest[Operation])\n\n  // Since both the `currentValue` and `update` endpoints return the same\n  // information, we define it once and just reuse it. Here, we say\n  // that they return an HTTP response whose entity contains a JSON document\n  // with the counter value\n  lazy val counterJsonResponse =\n    ok(jsonResponse[Counter], docs = Some(\"The counter current value\"))\n\n  // We generically derive a data type schema. This schema\n  // describes that the case class `Counter` has one field\n  // of type `Int` named “value”\n  implicit lazy val jsonSchemaCounter: JsonSchema[Counter] = genericJsonSchema\n  // Again, we generically derive a schema for the `Operation`\n  // data type. This schema describes that `Operation` can be\n  // either `Set` or `Add`, and that `Set` has one `Int` field\n  // name `value`, and `Add` has one `Int` field named `delta`\n  implicit lazy val jsonSchemaOperation: JsonSchema[Operation] =\n    genericJsonSchema\n}\nWe want to show our HTTP API documentation in Swagger UI so let’s define OpenAPI documentation.\nimport endpoints.openapi\nimport endpoints.openapi.model.{ Info, OpenApi }\n\nobject CounterDocumentation\n    extends CounterEndpoints\n    with openapi.Endpoints\n    with openapi.BasicAuthentication\n    with openapi.JsonEntitiesFromSchemas {\n\n  val api: OpenApi =\n    openApi(\n      Info(title = \"API to manipulate a counter\", version = \"1.0.0\")\n    )(currentValue, update)\n}\nIf we want to bring out HTTP API descriptions to life we need to interpret them, so lets do that.\nimport java.util.concurrent.atomic.AtomicInteger\nimport endpoints.uzhttp.server._\nimport zio.ZIO\n\nobject CounterServer extends CounterEndpoints with Endpoints with BasicAuthentication with JsonEntitiesFromSchemas {\n  parent =>\n\n  private val value = new AtomicInteger(0)\n\n  val username = \"username\"\n  val password = \"password\"\n\n  val handlers = (\n    currentValue.interpret { credentials =>\n      ZIO\n        .environment[zio.console.Console]\n        .flatMap(console =>\n          if (credentials.username == username && credentials.password == password)\n            ZIO(Some(Counter(value.get())))\n          else\n            console.get.putStr(s\"Invalid credentials $credentials\").map(_ => None)\n        )\n    } orElse\n      update.interpretPure {\n        case (Operation.Set(newValue), credentials)\n            if (credentials.username == username && credentials.password == password) =>\n          value.set(newValue)\n          Some(Counter(newValue))\n        case (Operation.Add(delta), credentials)\n            if (credentials.username == username && credentials.password == password) =>\n          val newValue = value.addAndGet(delta)\n          Some(Counter(newValue))\n        case _ => None\n      }\n  )\n}\nWe also need to interpret documentation endpoints, we will do that by using uzhttp implementation of Assets algebra.\nobject DocumentationServer extends Endpoints with JsonEntitiesFromEncodersAndDecoders with Assets {\n\n  // HTTP endpoint serving documentation. Uses the HTTP verb ''GET'' and the path\n  // ''/documentation.json''. Returns an OpenAPI document.\n  val documentation = endpoint[Unit, OpenApi](\n    get(path / \"documentation.json\"),\n    ok(jsonResponse[OpenApi])\n  )\n\n  // We “render” the OpenAPI document using the swagger-ui, provided as static assets\n  val assets = assetsEndpoint(path / \"assets\" / assetSegments())\n\n  val handlers = documentation.interpretPure(_ => CounterDocumentation.api) orElse\n    assets.interpretPure(assetResources(pathPrefix = Some(\"public\")))\n\n  override def digests: Map[String, String] = Map.empty\n}\nAll that is left is to serve our HTTP API is to run uzhttp server, so let’s to that.\nimport java.net.InetSocketAddress\nimport uzhttp.server.Server\nimport zio.App\n\nobject Main extends App {\n  override def run(args: List[String]): ZIO[zio.ZEnv, Nothing, Int] =\n    Server\n      .builder(new InetSocketAddress(\"127.0.0.1\", 8080))\n      .handleSome(\n        CounterServer.handlers orElse DocumentationServer.handlers\n      )\n      .serve\n      .useForever\n      .orDie\n}","title":"full-example"}]}