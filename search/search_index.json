{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"endpoints-uzhttp"},{"location":"/index.html#endpoints-uzhttp","text":"Endpoints server interpreter backed by uzhttp.\nYou Probably Shouldn’t Use It Because You Probably Shouldn’t Use uzhttp™.","title":"endpoints-uzhttp"},{"location":"/index.html#server","text":"\"io.github.jkobejs\" %% \"endpoints-uzhttp-server\" % \"0.0.0+4-909c80d0+20200521-0037-SNAPSHOT\"\nAPI documentation","title":"Server"},{"location":"/index.html#endpoints","text":"The Endpoints interpreter provides intepret and interpretaPure methods that can be chained using orElse method and integrated to your uzhttp server.\nFor instance, given the following endpoint definition:\nval items =\n  endpoint(\n    get(\n      path / \"items\" / segment[String](\"category\") /? qs[Option[Int]](\"page\")\n    ),\n    ok(\n      jsonResponse[List[Item]],\n      Some(\"List all the items of the given category\")\n    )\n  )\n\nval itemId = segment[String](\"id\")\n\nval item =\n  endpoint(\n    get(path / \"item\" / itemId),\n    wheneverFound(\n      ok(jsonResponse[Item], Some(\"The item identified by 'id'\")),\n      Some(\"Item not found\")\n    )\n  )\nIt can be implemented as follows:\nval handler: PartialFunction[uzhttp.Request, ZIO[Any with Blocking, HTTPError, uzhttp.Response]] =\n  items.interpretPure {\n    case (category, page) =>\n      List(Item(s\"first item from category $category and page $page\"))\n  } orElse\n  item.interpret(id => UIO.some(Item(id.toString)))\nThe result is a partial function that can be integrated in your server like any other partial function that satisfies given type definition using uzhttp.server.Server’s handleSome method.","title":"Endpoints"},{"location":"/index.html#error-handling","text":"When the server processes requests, three kinds of errors can happen: the incoming request doesn’t match any endpoint, the request does match an endpoint but is invalid (e.g. one parameter has a wrong type), or an exception is thrown.","title":"Error handling"},{"location":"/index.html#the-incoming-request-doesn-t-match-any-endpoint","text":"In that case, since interpreters return partial function of type\nPartialFunction[UzRequest, ZIO[R with Blocking, HTTPError, UzResponse]]\nuzhttp server will return 404 error.","title":"The incoming request doesn’t match any endpoint"},{"location":"/index.html#the-incoming-request-is-invalid","text":"In that case, endpoints returns a “Bad Request” (400) response reporting all the errors in a JSON array. You can change this behavior by overriding the handleClientErrors method.","title":"The incoming request is invalid"},{"location":"/index.html#an-exception-is-thrown","text":"If an exception is thrown during request decoding, or when running the business logic, or when encoding the response, endpoints returns an “Internal Server Error” (500) response reporting the error in a JSON array. You can change this behavior by overriding the handleServerError method.","title":"An exception is thrown"},{"location":"/full-example.html","text":"import java.net.InetSocketAddress\nimport java.util.concurrent.atomic.AtomicInteger\n\nimport endpoints.uzhttp.server._\nimport uzhttp.server.Server\nimport zio.{ App, ZIO }\n\ncase class Counter(value: Int)\n\nsealed trait Operation\nobject Operation {\n  case class Set(value: Int) extends Operation\n  case class Add(delta: Int) extends Operation\n}\n\nimport endpoints.{ algebra, generic }\n\ntrait CounterEndpoints\n    extends algebra.EndpointsWithCustomErrors\n    with algebra.JsonEntitiesFromSchemas\n    with algebra.BasicAuthentication\n    with generic.JsonSchemas {\n\n  val currentValue =\n    authenticatedEndpoint(Get, (path / \"counter\"), counterJsonResponse)\n\n  val update = authenticatedEndpoint(Post, path / \"counter\", counterJsonResponse, jsonRequest[Operation])\n\n  lazy val counterJsonResponse =\n    ok(jsonResponse[Counter], docs = Some(\"The counter current value\"))\n\n  implicit lazy val jsonSchemaCounter: JsonSchema[Counter] = genericJsonSchema\n  implicit lazy val jsonSchemaOperation: JsonSchema[Operation] =\n    genericJsonSchema\n}\n\nimport endpoints.openapi\nimport endpoints.openapi.model.{ Info, OpenApi }\n\nobject CounterDocumentation\n    extends CounterEndpoints\n    with openapi.Endpoints\n    with openapi.BasicAuthentication\n    with openapi.JsonEntitiesFromSchemas {\n\n  val api: OpenApi =\n    openApi(\n      Info(title = \"API to manipulate a counter\", version = \"1.0.0\")\n    )(currentValue, update)\n}\n\nobject CounterServer extends CounterEndpoints with Endpoints with BasicAuthentication with JsonEntitiesFromSchemas {\n  parent =>\n\n  private val value = new AtomicInteger(0)\n\n  val username = \"username\"\n  val password = \"password\"\n\n  val handlers = (\n    currentValue.interpret { credentials =>\n      ZIO\n        .environment[zio.console.Console]\n        .flatMap(console =>\n          if (credentials.username == username && credentials.password == password)\n            ZIO(Some(Counter(value.get())))\n          else\n            console.get.putStr(s\"Invalid credentials $credentials\").map(_ => None)\n        )\n    } orElse\n      update.interpretPure {\n        case (Operation.Set(newValue), credentials)\n            if (credentials.username == username && credentials.password == password) =>\n          value.set(newValue)\n          Some(Counter(newValue))\n        case (Operation.Add(delta), credentials)\n            if (credentials.username == username && credentials.password == password) =>\n          val newValue = value.addAndGet(delta)\n          Some(Counter(newValue))\n        case _ => None\n      }\n  )\n}\n\nobject DocumentationServer extends Endpoints with JsonEntitiesFromEncodersAndDecoders with Assets {\n\n  val documentation = endpoint[Unit, OpenApi](\n    get(path / \"documentation.json\"),\n    ok(jsonResponse[OpenApi])\n  )\n\n  val assets = assetsEndpoint(path / \"assets\" / assetSegments())\n\n  val handlers = documentation.interpretPure(_ => CounterDocumentation.api) orElse\n    assets.interpretPure(assetResources(pathPrefix = Some(\"public\")))\n\n  override def digests: Map[String, String] = Map.empty\n}\n\nobject Main extends App {\n  override def run(args: List[String]): ZIO[zio.ZEnv, Nothing, Int] =\n    Server\n      .builder(new InetSocketAddress(\"127.0.0.1\", 8080))\n      .handleSome(\n        CounterServer.handlers orElse DocumentationServer.handlers\n      )\n      .serve\n      .useForever\n      .orDie\n}","title":"· endpoints-uzhttp"}]}